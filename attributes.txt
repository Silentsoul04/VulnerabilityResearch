link to a SQL injection cheatsheet: 
https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.md

look at vulnerability papers for characteristics of complexity

Attributes/Features
*usesSQL - Files will need to use SQL for a SQL injection to be possible. This feature helps immediately identify files without SQL. To parse for this characteristic, search for the phrase "SQL" or common terms like "SELECT", "FROM", "WHERE" 

*usesStringConcatenation - Many SQL vulnerabilities occur from directly combining user input with a string that represents a SQL command. In PHP, the concatenation symbol is "." or ".=". Since variables are usually concatenated, " '.$ " is a common pattern that shows vulnerability.

*usesClientRequest - Involves data submitted through HTML forms and URLS. Examples include $_GET and $_POST. Although many applications use client requests and are often not vulnerable, when it comes to SQL injections, this is a direct user input, which is often where attacks come from.  

*lacksParameterizedQueries - Vulnerable files generally will NOT have parameterized queries. In PHP, a parameter is represented with a "?". Parameters will usually come after an equals sign, so parse for "= ?". For code that uses mysql, the mysqli_stmt_bind_param function will be used.

*lacksColon - In PHP, parameters in queries can also be achieved by using colons. The other main use for a colon is with a ternary operator, but these are usually uncommon.
Example from http://php.net/manual/en/pdo.prepared-statements.php:
<?php
$stmt = $dbh->prepare ("INSERT INTO user (firstname, surname) VALUES (:f_name, :s_name)");
$stmt -> bindParam(':f_name', 'John');
$stmt -> bindParam(':s_name', 'Smith');
$stmt -> execute();
?>

*lacksPDO - PDO is a class that helps write prepared statements w/ parameterized queries. Look for PDO(). The most important command is under the PDOStatement class; bindParam() binds a value to a parameter. Note that many databases have their own options for prepared statements. ex. PostgreSQL uses pg_prepare() and pg_execute().

*lacksPrepare - Prepared statements with parameteried queries are crucial for stopping SQL injections. Prepared statements are often called with the "prepare" statement, usually in a form like "$dbh->prepare("examplequery")"

*lacksStoredProcedure - Stored procedure often work like parameterized queries if they are implemented safely. They are not always secure of SQL injection vulnerabilities, but using them is usually safer than not using them. For MySQL databases, stored procedures will likely involve "IN", "INOUT", "OUT", and "CALL" keywords.

*lacksEscapeFunctions - SQL Injection can be avoided if user inputs are sanitized first. However, the escape functions themselves cannot be guaranteed to be safe. This characteristic may be hard to parse for because it requires explicit analysis of a function's purpose

*linesOfCode - Lines of code correlates with complexity, which has a light correlation to vulnerabilities.
Review "Using complexity, coupling, and cohesion metrics as early indicators of vulnerabilities" for source of this attribute.

*FanIn - Number of inputs a function takes in. A function may sanitize the inputs of some passed-in parameters, but not all of them. Likelier that functions w/ more parameters will forget to sanitize one.
May need to take max FanIn from a file. If no functions, return 0. 

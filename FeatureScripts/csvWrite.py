import os
import csv
import fileRetriever
import bagOfWords

def getFeatureColumns():
    feature_col_names = getAllRowHeaders()
    feature_col_names = feature_col_names[2:] #all except name and vulnerable column
    predicted_class_names = ['Vulnerable']
    return feature_col_names, predicted_class_names

def getRowHeaders():
    row = ['File Name', 'Vulnerable', 'Has Addslashes',
           'Has BindParam', 'Has Client Request', 'Has File Request',
           'Has HTMLEntities', 'Has HTMLSpecialChars', 'LOC',
           'Has Magicquotes', 'Has MySQLi', 'Has MySQLQuery',
           'Has MySQLRealEscapeString', 'Has Numeric Function',
           'Has PDO', 'Has PregMatch', 'Has Prepare', 'Has SQL Query',
           'Has String Concatenation', 'Has Trim'
           ]
    '''
    pass in list of word vector feature names
    concatenate lists
    '''
    return row

def getAllRowHeaders():
    headerRow = []

    filePath = getCSVDirectory()
    with open(filePath, "r", encoding="utf8", newline="") as dataFile:
        csvlines = csv.reader(dataFile, delimiter=',')
        for lineNum, line in enumerate(csvlines):
            if lineNum == 0:
                headerRow = line
                break
            else:
                break

    return headerRow

def getRowData(file):
    "get a csv row of a file's data"
    row = []
    #file name
    row.append(file.name)
    #vulnerable?
    row.append(file.checkVulnerability())
    #has addslashes()?
    row.append(file.checkAddSlashes())
    #has bindParam()?
    row.append(file.checkBindParam())
    #has client request?
    row.append(file.checkClientRequest())
    #has file request?
    row.append(file.checkFileRequest())
    #has htmlentities()?
    row.append(file.checkHTMLEntities())
    #has htmlspecialchars()?
    row.append(file.checkHTMLSpecialChars())
    #get lines of code
    row.append(file.checkLinesOfCode())
    #has magicquotes?
    row.append(file.checkMagicQuotes())
    #has mysqli?
    row.append(file.checkMySQLI())
    #has mysql_query?
    row.append(file.checkMySQLQuery())
    #has mysql_real_escape_string?
    row.append(file.checkMySQLRealEscapeString())
    #has numeric function?
    row.append(file.checkNumericFunction())
    #has pdo?
    row.append(file.checkPDO())
    #has preg_match?
    row.append(file.checkPregMatch())
    #has ->prepare?
    row.append(file.checkPrepare())
    #has sql query?
    row.append(file.checkSQLQuery())
    #has string concatenation?
    row.append(file.checkStringConcatenation())
    #has trim()?
    row.append(file.checkTrim())

    #replace True/False w/ 0/1
    for i in range(len(row)):
        if row[i] == True:
            row[i] = 1
        elif row[i] == False:
            row[i] = 0

    '''for entry in row:
        if entry == True:
            entry = 1
        elif entry == False:
            entry = 0'''

    '''
    pass in individual lists from featureList in testBagOfWords
    will need to iterate through list before passing in
    '''

    return row

def getNumFeatures():
    featureCount = 0
    filePath = getCSVDirectory()
    with open(filePath, "r", encoding="utf8", newline="") as dataFile:
        csvlines = csv.reader(dataFile, delimiter=',')
        for lineNum, line in enumerate(csvlines):
            if lineNum == 0:
                featureCount = len(line)
            else:
                break
    if featureCount != 0:
        featureCount -= 2 #cut out name and vulnerability column
    return featureCount

def getCSVDirectory(getUserFile=False):
    dirPath = os.path.dirname(os.path.realpath(__file__))
    filePath = os.path.join(dirPath, "fileInfo.csv")

    if getUserFile:
        filePath = os.path.join(dirPath, "inputFileInfo.csv")
    
    return filePath

#refactor to choose between normal createDataSet and a version that only uses function names
def createDataSet():
    #set fileInfo.csv path
    dirPath = os.path.dirname(os.path.realpath(__file__))
    filePath = os.path.join(dirPath, "fileInfo.csv")

    #reset data of fileInfo.csv
    f = open(filePath, "w", encoding="utf8")
    f.truncate()
    f.close()

    #get file set
    print("Choose file set. 0: collected, 1: juliet, 2: hybrid")
    fileSetChoice = int(input())
    files = fileRetriever.getFileSet(fileSetChoice)

    '''
    add in query to testBagOfWords
    '''

    #choose between using full bag of words and using only function names
    featureChoice = int(input("Use full bag of words (0) or only function names (1)? "))

    while featureChoice != 0 and featureChoice != 1:
        print("Input not valid. Try again.")
        featureChoice = int(input("Use full bag of words (0) or only function names (1)? "))

    wordNames = []
    wordFeatureList = [[]]

    if featureChoice == 0:
        wordNames, wordFeatureList = bagOfWords.getBagOfWords_tfidf(files)
    elif featureChoice == 1:
        wordNames, wordFeatureList = bagOfWords.getBagOfWords_functions(files)

    #collect data for rows of all files
    ownRowHeaders = getRowHeaders()
    allFeatureHeaders = ownRowHeaders + wordNames
    rowData = [allFeatureHeaders] #a combination of the self features and the feature vector features

    for i in range(len(files)):
        row = getRowData(files[i]) #self features
        row = row + wordFeatureList[i].tolist() #add word vector features to row
        rowData.append(row)

    print("Dir just before reopening file:", filePath)
    #reopen data file
    with open(filePath, "w+", encoding="utf8", newline="") as dataFile:
        writer = csv.writer(dataFile)
        writer.writerows(rowData)

def rewriteCSV():
    userInput = input("Rewrite csv? (y/n) ")
    if userInput == 'y':
        createDataSet()
        print("Data set recreated")

def extractFeatures(files):
    #extract features for user input files
    #takes in list of files
    #if single file, pass in as [file]
    '''if type(files) == list:
        pass
    else: #single file
        row = getRowData(files[i]) #self features
        #row = row + wordFeatureList[i].tolist() #add word vector features to row
        rowData.append(row)'''
    #set fileInfo.csv path
    dirPath = os.path.dirname(os.path.realpath(__file__))
    filePath = os.path.join(dirPath, "inputFileInfo.csv")

    #reset data of fileInfo.csv
    f = open(filePath, "w", encoding="utf8")
    f.truncate()
    f.close()

    #get features
    wordNames = []
    wordFeatureList = [[]]

    wordNames, wordFeatureList = bagOfWords.useBagOfWords_tfidf(files)

    #collect data for rows of all files
    ownRowHeaders = getRowHeaders()
    allFeatureHeaders = ownRowHeaders + wordNames
    rowData = [allFeatureHeaders] #a combination of the self features and the feature vector features

    for i in range(len(files)):
        row = getRowData(files[i]) #self features
        row = row + wordFeatureList[i].tolist() #add word vector features to row
        rowData.append(row)

    #reopen data file
    with open(filePath, "w+", encoding="utf8", newline="") as dataFile:
        writer = csv.writer(dataFile)
        writer.writerows(rowData)

def getCSVRows():
    #get file set
    '''print("Choose file set. 0: collected, 1: juliet, 2: hybrid")
    fileSetChoice = int(input())
    files = fileRetriever.getFileSet(fileSetChoice)

    #collect data for rows of all files
    rowData = [getRowHeaders()]

    for file in files:
        row = getRowData(file)
        rowData.append(row)

    return rowData'''
    filePath = getCSVDirectory()
    rowList = []
    with open(filePath, 'r', encoding="utf8") as f:
        reader = csv.reader(f)
        rowList = list(reader)

    return rowList
    

if __name__ == "__main__":
    #createDataSet()
    #print(getNumFeatures())
    #getAllRowHeaders()
    print(getCSVDirectory())
    print(getCSVDirectory(getUserFile=True))

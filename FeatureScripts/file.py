import re
#import rate

class File:
    def __init__(self, directory, fileName):
        self.dir = directory
        self.name = fileName #file name w/o whole directory
        # counts the number of vulnerability characteristics detected
        # higher number means less vulnerable
        # reduce number when vulner characteristic is met
        self.counter = 0 
        self.vulnerable = False

    def raiseCounter(self):
        self.counter += 1

    def lowerCounter(self):
        self.counter -= 1
    
    def resetCounter(self):
        self.counter = 0

    def showFile(self):
        print("[{}, {}]".format(self.name, self.counter))

    def showFileDirectory(self):
        print("[{}, {}, {}]".format(self.dir, self.name, self.counter))

    def getDir(self):
        return self.dir

    def getName(self):
        return self.name

    def getCounter(self):
        return self.counter

    #FIXME
    def findLinesOfCode(self):
        '''get the lines of code in a file and set the var'''
        pass
    
    def checkVulnerability(self):
        '''check if self.vulnerable matches whether or not the file is truly vulner'''
        #isolate 'Nonvulnerable' or 'Vulnerable' from self.dir
        #then compare to self.vulnerable

        if "Nonvulnerable" in self.dir:
            return False
        elif "Vulnerable" in self.dir:
            return True

    def checkAddSlashes(self):
        '''checks for addslashes function'''
        #regex pattern
        pattern = re.compile("addslashes") 

        with open(self.dir, encoding="utf8") as file:
            #boolean to check if function is found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter() #raise counter because secure practice found
                return True
            else:
                return False

    def checkBindParam(self):
        '''Checks for parameterized queries by using looking for bind_param functions'''
        #regex pattern
        #mysqli_stmt::bind_param
        pattern1 = re.compile("[bB][iI][nN][dD][_][pP][aA][rR][aA][mM]")
        #PDOStatement::bindParam
        pattern2 = re.compile("[bB][iI][nN][dD][pP][aA][rR][aA][mM]")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern1, line):
                    statementFound = True
                for match in re.finditer(pattern2, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter()
                return True
            else:
                return False

    def checkClientRequest(self):
        '''check for get, post requests'''
        #regex pattern
        pattern1 = re.compile("[$][_][gG][eE][tT]")
        pattern2 = re.compile("[$][_][pP][oO][sS][tT]")
        pattern3 = re.compile("[$][_][pP][uU][tT]")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            getFound = False
            postFound = False
            putFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern1, line):
                    getFound = True
                for match in re.finditer(pattern2, line):
                    postFound = True
                for match in re.finditer(pattern3, line):
                    putFound = True

            if getFound or postFound or putFound:
                return True
            else:
                return False

    def checkFileRequest(self):
        '''looks for Cookies. May add XML eventually'''
        #regex pattern
        pattern1 = re.compile("[$][_][hH][tT][tT][pP][_][cC][oO][oO][kK][iI][eE][_][vV][aA][rR][sS]")
        pattern2 = re.compile("[$][_][cC][oO][oO][kK][iI][eE]")

        with open(self.dir, encoding="utf8") as file:
            #boolean to check if function is found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern1, line):
                    statementFound = True
                for match in re.finditer(pattern2, line):
                    statementFound = True

            if statementFound:
                return True
            else:
                return False

    def checkHTMLEntities(self):
        '''looks for htmlentities function'''
        #regex pattern
        pattern = re.compile("htmlentities")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter()
                return True
            else:
                return False

    def checkHTMLSpecialChars(self):
        '''looks for htmlspecialchars function'''
        #regex pattern
        pattern = re.compile("htmlspecialchars")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter()
                return True
            else:
                return False

    def checkLinesOfCode(self):
        '''raises vulnerability counter if file's lines of code are higher than the average'''
        lineCount = 0
        with open(self.dir, encoding="utf8") as file:
            for i, line in enumerate(file): #[(0, line), (1, line)]
                lineCount += 1
        if lineCount <= 20: #small
            return 0
        elif lineCount <= 100: #medium
            return 1
        elif lineCount <= 250: #large
            return 2
        else: #larger
            return 3
        #return lineCount

    def checkMagicQuotes(self):
        '''checks if magic quotes are turned on.'''
        '''magic_quotes_gpc() may not be directly called, but get_magic_quotes_gpc() may'''
        #regex pattern
        pattern = re.compile("magic_quotes")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter()
                return True
            else:
                return False

    def checkMySQLI(self):
        '''Look for MySQLi library'''
        #regex pattern
        pattern = re.compile("mysqli")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter() #adds safety
                return True
            else:
                return False

    def checkMySQLQuery(self):
        '''looks for mysql_query() function. Not entirely safe, but blocks piggy-backed injections'''
        #regex pattern
        pattern = re.compile("mysql_query")

        with open(self.dir, encoding="utf8") as file:
            #boolean to check if function is found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                return True
            else:
                return False

    def checkMySQLRealEscapeString(self):
        '''looks for mysql_real_escape_string function'''
        #regex pattern
        pattern = re.compile("mysql_real_escape_string")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter() #adds safety
                return True
            else:
                return False

    def checkPDO(self):
        '''looks for pdo library, a prepared statements library'''
        #regex pattern
        pattern = re.compile("[pP][dD][oO]")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter() #adds safety
                return True
            else:
                return False

    def checkPregMatch(self):
        '''look for a regex comparison'''
        #regex pattern
        pattern = re.compile("preg_match")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter() #adds safety
                return True
            else:
                return False

    def checkPrepare(self):
        '''check for $dbh->prepare command'''
        #regex pattern
        pattern = re.compile("->prepare")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter()
                return True
            else:
                return False

    def checkSQLQuery(self):
        '''check if a file has a sql query. checks for FROM and WHERE'''
        #regex pattern
        pattern1 = re.compile("[fF][rR][oO][mM]")
        pattern2 = re.compile("[wW][hH][eE][rR][eE]")

        fromFound = False
        whereFound = False

        with open(self.dir, encoding="utf8") as file:
                for i, line in enumerate(file): #[(0, line), (1, line)]
                    for match in re.finditer(pattern1, line):
                        fromFound = True
                    for match in re.finditer(pattern2, line):
                        whereFound = True

        if fromFound and whereFound:
            return True
        else:
            self.raiseCounter() #no SQL query, so raise safety counter
            return False

    def checkStringConcatenation(self):
        #regex pattern
        pattern = re.compile(r"""['"]\s*[.]\s*[$]""")
        #do not need to check if it starts w/ ' because string concat will use '"

        #may need additional pattern for += queries ex. query += "author = '";
        #pattern = re.compile(r"""[a-zA-Z]\s*[+][=]\s*['"][a-zA-Z]""")

        conditionMet = False

        with open(self.dir, encoding="utf8") as file:
                for i, line in enumerate(file): #[(0, line), (1, line)]
                    for match in re.finditer(pattern, line):
                        conditionMet = True

        if conditionMet:
            self.lowerCounter() #lower counter because vulnerability found
            return True
        else:
            return False

    def checkTrim(self):
        '''looks for trim function'''
        #regex pattern
        pattern = re.compile("trim[(]")

        with open(self.dir, encoding="utf8") as file:
            #booleans to check if statements are found
            statementFound = False

            for i, line in enumerate(file): #[(0, line), (1, line)]
                for match in re.finditer(pattern, line):
                    statementFound = True

            if statementFound:
                self.raiseCounter()
                return True
            else:
                return False

    def vulnerabilityTest(self, score):
        '''returns True/False if a file is vulnerable or not'''
        '''score is the score that must be met to be nonvulner'''
        self.resetCounter()

        #tests
        #self.checkStringConcatenation()
        #self.checkPreparedStatement()
        #self.checkProcedure()
        #FIXME: add more tests

        #vulnerability check
        if self.counter >= score:
            self.vulnerable = False
            return False
        else:
            self.vulnerable = True
            return True

    def validityTest(self):
        '''check if self.vulnerable matches whether or not the file is truly vulner'''
        #isolate 'Nonvulnerable' or 'Vulnerable' from self.dir
        #then compare to self.vulnerable

        #document false positive and false negatives, etc.

        if "Nonvulnerable" in self.dir:
            if self.vulnerable == True:
                #false positive
                rate.raiseFalsePositiveCount()
            elif self.vulnerable == False:
                #true negative
                rate.raiseTrueNegativeCount()
        elif "Vulnerable" in self.dir:
            if self.vulnerable == True:
                #true positive
                rate.raiseTruePositiveCount()
            elif self.vulnerable == False:
                #false negative
                rate.raiseFalseNegativeCount()
        #else:
            #pass
